name: ☁️ Deploy to Dev (CD)

on:
  pull_request:
    branches: [main]
    types: [closed] # run when a PR gets closed; we'll guard for "merged" below

permissions:
  contents: write # to create tags
  id-token: write # for OIDC to assume the AWS role

concurrency:
  group: cd-dev
  cancel-in-progress: false

env:
  AWS_REGION: eu-central-1
  S3_BUCKET: ${{ vars.S3_BUCKET }}
  CLOUDFRONT_DISTRIBUTION_ID: ${{ vars.CLOUDFRONT_DISTRIBUTION_ID }}
  APP_DEPLOY_ROLE_TO_ASSUME_ARN: ${{ vars.APP_DEPLOY_ROLE_TO_ASSUME_ARN }}
  CDK_ROLE_TO_ASSUME_ARN: ${{ vars.CDK_ROLE_TO_ASSUME_ARN }}

jobs:
  changes:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    outputs:
      app: ${{ steps.filter-app.outputs.app }}
      infra: ${{ steps.filter-infra.outputs.infra }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - id: filter-app
        uses: dorny/paths-filter@v3
        with:
          filters: |
            app:
              - 'src/**'
              - 'angular.json'
              - 'package.json'
              - 'package-lock.json'
              - 'tsconfig*.json'
              - 'eslint.config.js'

      - id: filter-infra
        uses: dorny/paths-filter@v3
        with:
          filters: |
            infra:
              - 'infra/lib/**'

  cdk-deploy:
    needs: [changes]
    if: github.event.pull_request.merged == true && needs.changes.outputs.infra == 'true'
    runs-on: ubuntu-latest
    environment: dev

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials for CDK deploy
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.CDK_ROLE_TO_ASSUME_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Node.js for CDK
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install infra dependencies
        working-directory: infra
        run: npm ci

      - name: Deploy CDK stack
        working-directory: infra
        run: |
          npx cdk deploy --all --require-approval never --verbose

  build-deploy:
    needs: [changes]
    if: github.event.pull_request.merged == true && needs.changes.outputs.app == 'true'
    runs-on: ubuntu-latest
    environment: dev

    outputs:
      dist_dir: ${{ steps.dist.outputs.dir }}

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build Angular
        run: npx ng build --configuration production

      - name: Resolve dist path
        id: dist
        shell: bash
        run: |
          # heuristics to find the actual dist folder:
          if [ -d "dist" ]; then
            SUB=$(ls -1 dist | head -n 1 || true)
            if [ -n "$SUB" ] && [ -d "dist/$SUB/browser" ]; then
              echo "dir=dist/$SUB/browser" >> "$GITHUB_OUTPUT"
            elif [ -n "$SUB" ] && [ -d "dist/$SUB" ]; then
              echo "dir=dist/$SUB" >> "$GITHUB_OUTPUT"
            else
              echo "dir=dist" >> "$GITHUB_OUTPUT"
            fi
          else
            echo "dist/ not found"; exit 1
          fi
          echo "Using dist dir: $(cat $GITHUB_OUTPUT)"

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.APP_DEPLOY_ROLE_TO_ASSUME_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Upload static assets (immutable)
        run: |
          aws s3 sync "${{ steps.dist.outputs.dir }}/" "s3://${S3_BUCKET}/" \
            --delete \
            --exclude "index.html" \
            --cache-control "public, max-age=31536000, immutable"

      - name: Upload index.html (no-cache)
        run: |
          aws s3 cp "${{ steps.dist.outputs.dir }}/index.html" "s3://${S3_BUCKET}/index.html" \
            --cache-control "public, max-age=0, must-revalidate" \
            --content-type "text/html; charset=utf-8"

      - name: Invalidate CloudFront
        run: |
          aws cloudfront create-invalidation \
            --distribution-id "${CLOUDFRONT_DISTRIBUTION_ID}" \
            --paths "/*"

      - name: Upload build artifact for release
        if: ${{ success() }}
        uses: actions/upload-artifact@v4
        with:
          name: dist
          path: ${{ steps.dist.outputs.dir }}

  tag-release:
    needs: build-deploy
    if: needs.build-deploy.result == 'success' && github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    outputs:
      new_tag: ${{ steps.tag.outputs.new_tag }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Decide semver bump from labels
        id: bump
        if: ${{ success() }}
        shell: bash
        env:
          PR_LABELS_JSON: ${{ toJson(github.event.pull_request.labels) }}
        run: |
          set -euo pipefail
          bump=patch
          if echo "$PR_LABELS_JSON" | jq -e '.[] | select(.name=="semver:major")' >/dev/null; then
            bump=major
          elif echo "$PR_LABELS_JSON" | jq -e '.[] | select(.name=="semver:minor")' >/dev/null; then
            bump=minor
          elif echo "$PR_LABELS_JSON" | jq -e '.[] | select(.name=="semver:patch")' >/dev/null; then
            bump=patch
          fi
          echo "bump=$bump"
          echo "bump=$bump" >> "$GITHUB_OUTPUT"

      - name: Tag release
        id: tag
        if: ${{ success() }}
        shell: bash
        env:
          BUMP: ${{ steps.bump.outputs.bump }}
        run: |
          set -euo pipefail
          git config user.name  "github-actions"
          git config user.email "<>"

          # Ensure tags are available
          git fetch --tags --force

          # Fallback to v0.0.0 if no tags exist
          LAST_TAG="$(git describe --tags --abbrev=0 2>/dev/null || echo 'v0.0.0')"
          echo "Last tag: ${LAST_TAG}"
          VER="${LAST_TAG#v}"
          IFS='.' read -r MA MI PA <<< "${VER}"

          re='^[0-9]+$'
          [[ "$MA" =~ $re ]] || MA=0
          [[ "$MI" =~ $re ]] || MI=0
          [[ "$PA" =~ $re ]] || PA=0

          case "${BUMP}" in
            major) MA=$((MA+1)); MI=0; PA=0 ;;
            minor) MI=$((MI+1)); PA=0 ;;
            patch) PA=$((PA+1)) ;;
          esac

          NEW_TAG="v${MA}.${MI}.${PA}"
          echo "New tag: ${NEW_TAG}"

          # Idempotency: skip if tag already exists
          if git rev-parse -q --verify "refs/tags/${NEW_TAG}" >/dev/null; then
            echo "Tag ${NEW_TAG} already exists; skipping push."
            exit 0
          fi

          # Tag the merge commit that actually landed in main
          git tag -a "${NEW_TAG}" "${{ github.event.pull_request.merge_commit_sha }}" -m "release: ${NEW_TAG}"
          git push origin "${NEW_TAG}"
          echo "new_tag=${NEW_TAG}" >> "$GITHUB_OUTPUT"

      - name: Add info to job summary
        run: |
          echo "## Deploy summary" >> "$GITHUB_STEP_SUMMARY"
          echo "- New tag: ${{ steps.tag.outputs.new_tag }}" >> "$GITHUB_STEP_SUMMARY"
          echo "- Environment: dev" >> "$GITHUB_STEP_SUMMARY"

  github-release:
    needs: [build-deploy, tag-release]
    if: needs.build-deploy.result == 'success' && needs.tag-release.result == 'success' && needs.tag-release.outputs.new_tag != ''
    runs-on: ubuntu-latest

    steps:
      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: dist
          path: dist

      - name: Create GitHub Release with build artifacts
        uses: softprops/action-gh-release@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          tag_name: ${{ needs.tag-release.outputs.new_tag }}
          name: ${{ needs.tag-release.outputs.new_tag }}
          draft: false
          prerelease: false
          files: |
            dist/**

  update-version-file:
    needs: tag-release
    if: needs.tag-release.result == 'success' && needs.tag-release.outputs.new_tag != ''
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Update config.json in src/app
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p src/app

          NEW_TAG="${{ needs.tag-release.outputs.new_tag }}"
          CFG="src/app/config.json"

          if [ -f "$CFG" ]; then
            # Update or insert "version" field while preserving other keys
            node -e "
              const fs=require('fs'); const p='$CFG';
              const data=JSON.parse(fs.readFileSync(p,'utf8'));
              data.version='${NEW_TAG}';
              fs.writeFileSync(p, JSON.stringify(data, null, 2) + '\n');
            "
          else
            # Create a minimal config with version
            printf '{\n  "version": "%s"\n}\n' "${NEW_TAG}" > "$CFG"
          fi

          git add "$CFG"
          git config user.name  "github-actions"
          git config user.email "<>"
          # Only commit if there are changes
          if ! git diff --cached --quiet; then
            git commit -m "chore: update src/app/config.json to ${NEW_TAG}"
            # Push back to default branch (main)
            git push origin main
          else
            echo "No changes to commit for $CFG"
          fi
